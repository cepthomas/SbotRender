import collections
import datetime
import functools
import inspect
import os
import pathlib
import platform
import shutil
import subprocess
import sys
import threading
import time
import traceback
import sublime


### Do not edit this file - it will be overwritten.


#-----------------------------------------------------------------------------------
#---------------------------- Public defs ------------------------------------------
#-----------------------------------------------------------------------------------

# Data type.
HighlightInfo = collections.namedtuple('HighlightInfo', 'scope_name, region_name, type')

# Log defs.
LL_ERROR = 0
LL_WARN = 1
LL_INFO = 2
LL_DEBUG = 3


#-----------------------------------------------------------------------------------
#---------------------------- Private fields ---------------------------------------
#-----------------------------------------------------------------------------------

# Internal flag.
_temp_view_id = None

# Log defs.
_LOG_FILE_NAME = 'sbot.log'
_level_to_name = {LL_ERROR:'ERR', LL_WARN:'WRN', LL_INFO:'INF', LL_DEBUG:'DBG'}
_name_to_level = {v: k for k, v in _level_to_name.items()}
_log_level = LL_INFO
_tell_level = LL_INFO
_log_fn = None

# Trace defs.
_ftrace = None
_trace_start_time = 0


#-----------------------------------------------------------------------------------
#---------------------------- Public logger functions ------------------------------
#-----------------------------------------------------------------------------------

def log_error(message):
    '''Convenience function.'''
    _write_log(LL_ERROR, message)

def log_warn(message):
    '''Convenience function.'''
    _write_log(LL_WARN, message)

def log_info(message):
    '''Convenience function.'''
    _write_log(LL_INFO, message)

def log_debug(message):
    '''Convenience function.'''
    _write_log(LL_DEBUG, message)

def set_log_level(level):
    '''Set current log level.'''
    _log_level = _convert_log_level(level)

def set_tell_level(level):
    '''Set level to send to stdout.'''
    _tell_level = _convert_log_level(level)


#-----------------------------------------------------------------------------------
#---------------------------- Public trace functions -------------------------------
#-----------------------------------------------------------------------------------

#---------------------------------------------------------------------------
def start_trace(name, clean_file=True):
    '''Enables tracing and optionally clean file (default is True).'''
    global _ftrace
    global _trace_start_time

    trace_fn = get_store_fn(f'sbot_trace_{name}.log')

    if clean_file:
        with open(trace_fn, 'w'):
            pass

    # Open file now. Doing it on every write is too expensive.
    _ftrace = open(trace_fn, 'a')
    _trace_start_time = _get_ns()


#---------------------------------------------------------------------------
def stop_trace(clean_file=True): 
    '''Stop tracing.'''
    global _ftrace

    if _ftrace is not None:
        _ftrace.flush()
        _ftrace.close()
        _ftrace = None


#---------------------------------------------------------------------------
def T(msg):
    '''Trace function for user code.'''
    if _ftrace is not None:
        _trace(msg, 2)


#---------------------------------------------------------------------------
def traced_function(f):
    '''Decorator to support function entry/exit tracing.'''
    # Check for enabled.
    # if _ftrace is None:
    #     return f

    @functools.wraps(f)
    def wrapper(*args, **kwargs):
        parts = [f'{f.__name__}(enter)']
        if len(args) > 0:
            parts.append(f'args:{args}')
        if len(kwargs) > 0:
            parts.append(f'kwargs:{kwargs}')
        _trace(' '.join(parts))

        stat = 0
        res = None
        try:
            res = f(*args, **kwargs)
        except Exception as e:
            # _trace(e)
            _trace(traceback.format_exc())
            stat = 1

        _trace(f'{f.__name__}(exit) stat:{stat} res:{res} type:{type(res)}')
        return (stat, res)
    return wrapper


#-----------------------------------------------------------------------------------
#---------------------------- Public utility functions -----------------------------
#-----------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------
def get_store_fn(fn):
    '''Get store simple file name.'''
    store_path = os.path.join(sublime.packages_path(), 'User', '.SbotStore')
    pathlib.Path(store_path).mkdir(parents=True, exist_ok=True)
    store_fn = os.path.join(store_path, fn)
    return store_fn


#-----------------------------------------------------------------------------------
def get_store_fn_for_project(project_fn, file_ext):
    '''Get store file name based on ST project name.'''
    store_fn = None
    if project_fn is not None:
        fn = os.path.basename(project_fn).replace('.sublime-project', file_ext)
        store_fn = get_store_fn(fn)
    return store_fn


#-----------------------------------------------------------------------------------
def get_single_caret(view):
    '''Get current caret position for one only region. If multiples, return None.'''
    if len(view.sel()) == 0:
        raise RuntimeError('No data')
    elif len(view.sel()) == 1:  # single sel
        return view.sel()[0].b
    else:  # multi sel
        return None


#-----------------------------------------------------------------------------------
def get_sel_regions(view):
    '''Function to get user selection or the whole view if no selection.'''
    regions = []
    if len(view.sel()[0]) > 0:  # user sel
        regions = view.sel()
    else:
        regions = [sublime.Region(0, view.size())]
    return regions


#-----------------------------------------------------------------------------------
def create_new_view(window, text, reuse=True):
    '''Creates or reuse existing temp view with text. Returns the view.'''
    view = None
    global _temp_view_id

    # Locate the current temp view. This will silently fail if there isn't one.
    if reuse:
        for v in window.views():
            if v.id() == _temp_view_id:
                view = v
                break

    if view is None:
        # New instance.
        view = window.new_file()
        view.set_scratch(True)
        _temp_view_id = view.id()

    # Create/populate the view.
    view.run_command('select_all')
    view.run_command('cut')
    view.run_command('append', {'characters': text})  # insert has some odd behavior - indentation
    
    window.focus_view(view)

    return view


#-----------------------------------------------------------------------------------
def wait_load_file(window, fpath, line):
    '''Open file asynchronously then position at line. Returns the new View or None if failed.'''
    vnew = None

    def _load(view):
        if vnew.is_loading():
            sublime.set_timeout(lambda: _load(vnew), 10)  # maybe not forever?
        else:
            vnew.run_command("goto_line", {"line": line})

    # Open the file in a new view.
    try:
        vnew = window.open_file(fpath)
        _load(vnew)
    except Exception as e:
        sc.log_error(f'Failed to open {fpath}: {e}')
        vnew = None

    return vnew


#-----------------------------------------------------------------------------------
def get_highlight_info(which='all'):
    '''Get list of builtin scope names and corresponding region names as list of HighlightInfo.'''
    hl_info = []
    if which == 'all' or which == 'user':
        for i in range(6):  # magic number of markup.user_hl* count.
            hl_info.append(HighlightInfo(f'markup.user_hl{i + 1}', f'region_user_hl{i + 1}', 'user'))
    if which == 'all' or which == 'fixed':
        for i in range(3):  # magic number of markup.fixed_hl* count.
            hl_info.append(HighlightInfo(f'markup.fixed_hl{i + 1}', f'region_fixed_hl{i + 1}', 'fixed'))
    return hl_info


#-----------------------------------------------------------------------------------
def expand_vars(s: str):
    '''Smarter version of builtin. Returns expanded string or None if bad var name.'''
    done = False
    count = 0
    while not done:
        if '$' in s:
            sexp = os.path.expandvars(s)
            if s == sexp:
                # Invalid var.
                s = None
                done = True
            else:
                # Go around again.
                s = sexp
        else:
            # Done expanding.
            done = True

        # limit iterations
        if not done:
            count += 1
            if count >= 3:
                done = True
                s = None
    return s


#-----------------------------------------------------------------------------------
def get_path_parts(window, paths):
    '''
    Slide and dice into useful parts. paths is a list of which only the first is considered.
    Returns (dir, fn, path) where:
    - path is fully expanded path or None if invalid.
    - fn is None for a directory.
    '''
    dir = None
    fn = None
    path = None

    view = window.active_view()

    if paths is not None and len(paths) > 0:  # came from sidebar
        # Get the first element of paths.
        path = paths[0]
    elif view is not None:  # came from view menu
        # Get the view file.
        path = view.file_name()
    else:  # maybe image preview - dig out file name
        path = window.extract_variables().get('file')

    if path is not None:
        exp_path = expand_vars(path)
        if os.path.isdir(exp_path):
            dir = exp_path
        else:
            dir, fn = os.path.split(exp_path)
        path = exp_path

    return (dir, fn, path)


#-----------------------------------------------------------------------------------
def open_path(path):
    '''Acts as if you had clicked the path in the UI. Honors your file associations.'''
    if platform.system() == 'Darwin':
        log_error('Sorry, we don\'t do Macs')
    elif platform.system() == 'Windows':
        os.startfile(path)
    else:  # linux variants
        subprocess.run(('xdg-open', path))
    return True
    

#-----------------------------------------------------------------------------------
def open_terminal(where):
    '''Open a terminal in where.'''

    # This works for gnome. Maybe should support other desktop types?
    # Kde -> konsole
    # xfce4 -> xfce4-terminal
    # Cinnamon -> x-terminal-emulator
    # MATE -> mate-terminal --window
    # Unity -> gnome-terminal --profile=Default

    if platform.system() == 'Darwin':
        log_error('Sorry, we don\'t do Macs')
    elif platform.system() == 'Windows':
        cmd = f'wt -d "{where}"'  # W10+
    else:  # linux + mac(?)
        cmd = f'gnome-terminal --working-directory="{where}"'
    subprocess.run(cmd, shell=False, check=False)


#-----------------------------------------------------------------------------------
#---------------------------- Private functions ------------------------------------
#-----------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------
def _convert_log_level(level):
    '''Convert arg (str or int) into a valid log level.'''
    new_level = -1
    if type(level) is int:
        new_level = level
    elif type(level) is str:
        if level in _name_to_level:
            new_level = _name_to_level[level]
    if new_level not in _level_to_name:
        raise ValueError(f'Invalid log level: {level}')
    return new_level


#-----------------------------------------------------------------------------------
def _write_log(level, message):
    '''Format a standard message with caller info and log it.'''
    # Gates. Sometimes get stray empty lines.
    if len(message) == 0:
        return
    if len(message) == 1 and message[0] == '\n':
        return
    if level > _log_level:
        return

    # Get caller info.
    frame = sys._getframe(2)
    fn = os.path.basename(frame.f_code.co_filename)
    line = frame.f_lineno
    # f'func = {frame.f_code.co_name}'
    # f'mod_name = {frame.f_globals["__name__"]}'
    # f'class_name = {frame.f_locals["self"].__class__.__name__}'

    slvl = _level_to_name[level] if level in _level_to_name else '???'
    time_str = f'{str(datetime.datetime.now())}'[0:-3]

    # Write the record.
    # I don't think file access needs to be synchronized. ST docs say that API runs on one thread. But?
    with open(_log_fn, 'a') as log:
        out_line = f'{time_str} {slvl} {fn}:{line} {message}'
        log.write(out_line + '\n')
        log.flush()

    # Write to console also?
    if level <= _tell_level:
        out_line = f'>>> {slvl} {fn}:{line} {message}'
        sys.stdout.write(out_line + '\n')
        sys.stdout.flush()


#---------------------------------------------------------------------------
def _get_ns():
    '''Get current nanosecond.'''
    if platform.system() == 'Darwin':
        log_error('Sorry, we don\'t do Macs')
    elif platform.system() == 'Windows':
        return time.perf_counter_ns()
    else:  # linux variants
        return time.clock_gettime_ns(time.CLOCK_MONOTONIC)


#---------------------------------------------------------------------------
def _trace(msg, stkpos=None):
    '''Do one trace record. if stkpos not None determine the function/line info too.'''
    elapsed = _get_ns() - _trace_start_time
    msec = elapsed // 1000000
    usec = elapsed // 1000

    if stkpos is not None:
        frame = sys._getframe(stkpos)
        if 'self' in frame.f_locals:
            class_name = frame.f_locals['self'].__class__.__name__
            func = f'{class_name}.{frame.f_code.co_name}'
        else:
            func = frame.f_code.co_name  # could be '<module>'
        s = f'{msec:04}.{usec:03} {func}({frame.f_lineno}) {msg}\n'
    else:
        s = f'{msec:04}.{usec:03} {msg}\n'

    print(s)        

    # Write the record. TODO1 if file is locked by other process notify user that trace is one module only.
    _ftrace.write(s)


#-----------------------------------------------------------------------------------
def _notify_exception(exc_type, exc_value, exc_traceback):
    '''Process unhandled exceptions and notify user.'''

    # Sometimes gets this on shutdown: FileNotFoundError '...Log\plugin_host-3.8-on_exit.log'
    if issubclass(exc_type, FileNotFoundError):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return

    msg = f'Unhandled exception {exc_type.__name__}: {exc_value}'
    stb = traceback.format_tb(exc_traceback)
    stb.insert(0, msg)
    stb = '\n'.join(stb)
    log_error(stb)
    sublime.error_message(msg)


#-----------------------------------------------------------------------------------
#----------------------- Finish initialization -------------------------------------
#-----------------------------------------------------------------------------------

_log_fn = get_store_fn(_LOG_FILE_NAME)

# Connect the last chance hook. TODO should be done once/global.
# sys.excepthook = _notify_exception

# Maybe roll over log now.
if os.path.exists(_log_fn) and os.path.getsize(_log_fn) > 50000:
    bup = _log_fn.replace('.', '_old.')
    shutil.copyfile(_log_fn, bup)
    # Clear current log file.
    with open(_log_fn, 'w'):
        pass
